//parsing

3) voir env -i
4) si qu'un seul mot et ce n'est pas une commande, error

TOKENIZATION

/* étapes */

//1 récuperer ligne de commande (fichier input)
//2 analyse lexicale : découper la ligne de commande en token grace aux séparateurs
    //espaces, tabulations
    //retour à la ligne
    //guillements
//3 Analyse syntaxique : identifier la structure syntaxique de la ligne de commande (le type)
//4 Analyse sémantique : interpréter les tokens pour leur donner un sens (ex identifier les cmd, les variables, les options,...)
//5 execution


Analyse lexicale :
//1 chaîne de caractères de la ligne de commande lue et stockée
//2 elimination des caractères blancs (espace, tab, retour à la ligne)
//3 détéction des guillemets
//4 division en tokens
//5 retour des tokens


analyse syntaxique :
/* Vérifier que la séquence d'elt lexicaux créée pdt l'analyse lexical est cohérente avec la grammaire du langage (respecte règles syntaxiques)*/

//1 création de l'arbre syntaxique: séquence d'éléments lexicaux est analysée pour créer un arbre s, qui représente la structure syntaxique de l'expression
//2 Validation de la grammaire: arbre validé pour assurer qu'il respect regle de grammaire. ex: vérifie que les opérateurs sont utilisés correctement, instruction correctement imbriqués
//3 detection erreurs de syntaxe
//4 gestion des priorités: inclure étape pour gerer prio des opérateurs
//5 transformation de l'arbre


analyse semantique :
/*but : vérifier que les elt lexicaux et les expressions syntaxiques crées pdt les étapes précédentes
sont cohérentes sémantiquement parlant: qu'ils ont un sens et une interprétation valides*/

//1 verificaton des types. ex: les opérateurs sont appliqués à des types compatibles, les fonctions sont appelées avec les bons arguments, les var sont déclarées et initialisées correctement
//2 Résolution des noms: les noms des fonctions, variables, et autres symboles sont résolus: ex verif que fonctions appelées avc le bon nom
    //que les var sont déclarées avant leur utilisation, symboles def dans le bon espace de nom, etc
//3 Analyse de flux de contrôle: on verifie que instructions de boucle ont des contions d'arrêt valide, instructions d'exception correctement gérée, etc
//4 génération de code intermediaire: une fois que elt lexicaux et expression ont été verif sémantiquement, un code interm peut être généré pour faciliter l'opti et la generation du code final






Analyse syntaxique : Cette étape consiste à analyser la commande entrée par l'utilisateur et à la diviser en éléments significatifs tels que la commande, les options et les arguments.

Recherche de commande : Après avoir analysé la commande, le shell doit rechercher la commande correspondante dans le chemin d'accès (PATH) spécifié dans la variable d'environnement $PATH.

Création de processus : Si le shell trouve la commande, il crée un nouveau processus fils en utilisant la fonction système fork().

Redirection des entrées/sorties : Le shell peut également rediriger les entrées/sorties standard de la commande en utilisant les opérateurs de redirection tels que ">", "<", ">>" ou "|".

Exécution de la commande : Le processus fils exécute la commande à l'aide de la fonction système exec() en utilisant le chemin d'accès complet de la commande.

Attente de la fin de la commande : Après l'exécution de la commande, le processus père attend la fin de l'exécution du processus fils.

Traitement des signaux : Pendant l'exécution de la commande, le processus peut recevoir des signaux tels que SIGINT ou SIGTERM. Le shell doit traiter ces signaux et agir en conséquence.

Retour de la valeur de sortie : Enfin, le processus fils renvoie une valeur de sortie au processus père. Cette valeur est stockée dans la variable $? du shell.

